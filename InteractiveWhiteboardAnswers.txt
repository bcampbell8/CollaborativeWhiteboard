
Interactive Whiteboard Answers

Key: numbers listed are questions which have not been compeleted, parts listed have not been started
Numbers in brackets by parts are the number of questions in that part.
A question answered with "done" means it was written directly into the word document.
A question mark next to a question number indicates the question is mostly done (just requires
screenshots be taken or minor adjustments be made)

Part 2		: 10?, 12? - answers are there, not sure how complete they are

Part 3 (31)	: 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10, 3.11, 3.12, 3.13, 3.14, 3.15, 3.16, 3.17, 3.18, 3.19
		  3.20, 3.21, 3.22, 3.23, 3.24, 3.25, 3.26, 3.28
Part 4 (4)	: 1?, 2?, 3, 4
Part 5 (2)	: 1?, 2?



1.1
Responsive design, iconography, and performance optimisation are three web design techniques for hand-held
devices. Responsive design means the design doesn't just work on a mobile device, it changes to make the
site continue to look good despite the screen size. Iconography helps with responsive design in shrinking
buttons using icons so that the text on the button does not need to be big. Performance optimisation is
about making sure that a small (usually not powerful device) can still handle the webpage without slowing
down or heating up too much.


1.2
iphone, tablet, laptop


1.3
XML and JSON can be used in mobile applications to exchange data over the network without completely
reloading the page, or in native applications to retrieve data from a central server.


1.4
Two SDLCs that are relevant to medium and large projects are the waterfall and the agile methods of developing software.
The waterfall method carries the idea of fully completing one stage of the development before moving on to the next
one, for example designing the code for everything before ever writing any of it. The agile method is about being able
to quickly jump from one part of the process to another, designing the structure of the database while writing the
code to test the business logic. These are applied as ways of managing the workload and flow of projects.

1.5
done

1.6
An array is a collection of elements with a fixed size, where all of the elements are (generally) the same type.
A list is an array which can be resized when adding or removing items
A linked list is similar to an array or a list that doesn't need a continuous block of memory to store values,
instead it stores the value and a pointer to the next value so that the items can be dispersed throughout memory
but still accessed in order
A stack is a first in last out ordering of items similar to a stack of plates - you can put another one on the top,
but that one has to be the first to be removed before any others can be removed
A queue is a first in first out ordering of items similar to a queue for a ride at lunar park - the first person to
show up and join the queue will be first to go on the ride, and subsequent people to show up will ride in the same
order they joined the queue
A tree is a linked list, except each item can have more than one child element
A graph is a tree with no defined root - each item can point to any number of other items, which may or may not
have pointers returning to the first item
A set is a list which does not allow duplicate items
A hash table is a fancy way of taking something that is not an integer index accessor and turning it into one,
meaning 2 sets of data can be linked in a one to one fashion

1.7
1. Ensure style guides are followed - helps with code readability, linting, and maintainance
2. Have test cases to cover as much as possible - helps with demonstrating what is working and reducing regressions
3. Create documentation for everything - helps with maintainance


1.8
1. Consider the function requirements and how well this library applies to them
2. Verify what licence the library is under, and what that means for your code
3. Verify the library is still being maintained with security updates and other support
4. Consider how easy it would be to get someone new in who knows this library (if the previous person left)
5. If the library is not open for your use case, consider the price for use in a condition that is better for you
6. Consider other non-functional requirements such as performance



1.9
printing values or throwing exceptions with values in the message portion to the console to show what
they are at particular stages in the program, and the debugger that is built into certain programs,
such as the js debugger in most browsers

remote debugging, node debugger


1.10
1. Reproduce the issue by setting up the same circumstances which caused it in the first place
2. Locate the bug by analysing the code to narrow it down
3. Identify the root cause by examining the logic and flow of the code
4. Fix the bug by making changes and testing the code
5. Test the fix - if it didn't work, return to step 2
6. Mark issue as fixed

1.11
Keeping code maintainable can be done in a number of ways, but removing unused files, adding a date for
when things were last updated (to functions, classes, etc), and carefully tracking issues speed up
maintainence significantly. Removing unused files speeds up maintainence by making it easier for a
developer to sort through everything and making the project folder cleaner. Tracking issues makes
maintenance easier because the maintainer does not need to keep a lot of information in their head
about everything, and instead can write it down in an organised way. Maintenance is also made easier
if everything has a date for when it was last edited - this makes it easy to know if something is
part of legacy code or heavily involved in the progression and development of the application.


1.12
Postman and curl are two REST API clients which may be suitable for testing this project. Both
provide the required suite of tools to make HTTP requests, but curl is a pre-installed tool in
most systems, while postman requires installation in VScode, which makes curl easier in terms of
setup. However, Postman has a GUI, which makes it more user friendly. Between the two, curl's
cli interactions are not unintuitive, and it's pre-installation makes it more suitable for use
in this project.

1.13
JsDoc and Swagger are both extensive open source documentation tools for code, with swagger being
specifically geared toward rest APIs, compared to jsdoc which is more generalist. However, swagger
is a paid tool (although it has a free version), and jsdoc is licenced under the apache 2.0
licence meaning it is free to use (under a few non-restrictive terms).

1.14
The four main names for api methods are Create, Read, Update, and Delete, while a common fifth method
is a secondary update method, similar to HTTP's PATCH or PUT methods, or a Status method which would
return information about the system's internal state or readiness. The five methods provide all the
necessary functionality to interact with data through an api.

1.15
HTTP uses a request/response style, and every request has a method, route, and version which define
which resource the client is requesting. A request frequently has headers and sometimes has a body,
while a response has a version, status code, reason phrase, headers, and a body. HTTP is mostly used
for distributed, collaborative hypermedia information systems - usually hypertext documents such as
those that use HTML.

1.16
A request has structure:
```
<Method> <Route> <Version>
<Header Key>: <Header Value>
<Header Key>: <Header Value>
...

<Body>
```

While a response has structure
```
<Version> <Status code> <Reason phrase>
<Header Key>: <Header Value>
<Header Key>: <Header Value>
...

<Body>
```

HTTP methods include GET, POST, PUT, PATCH, DELETE, and OPTIONS. Routes look like file paths from
a root directory "/". To request top level javascript content, the route would probably be
"/scripts.js", compared to a subpage in the Products page: "/Products/Teapots". The version is
almost always "HTTP/1.1" for both request and response. Headers provide more information about the
body, for example "Content-Type: application/json". A request does not always have a body, whereas
a response pretty much always has a body.


1.17
done

1.18
enabling data from other places (Cross Origin Resource Sharing)
done


part 2:

2.1
The project must produce a product which must allow drawing inputs, as well as it must be:
. Collaborative
. Responsive (screen responsive and fast on the backend)
. Easy to get started
. Easy to share a link to a session
. Endless (have infinite scrolling)

2.2
The system will be made in Typescript - the frontend will be compiled from React Typescript
into HTML/JS, and the backend natively supports Typescript.

2.3
The vast majority of the mobile devices that will be used by the client to interact with this project
will have a touchscreen, will have multitouch and gesture features, and most of them will also be
small, meaning features need to adjust in size to not be inaccessible, but also not take up the
entire screen.

2.4
The mobile devices that will interact with this project will have to have all the basic features
of an ICT device such as a screen, ram, cpu, and network connection, as well as a browser to access
the web page of the project.

2.5
done

2.6
/create, /join, /findroom

This project uses a combination of three sets of network endpoints, where one set is the websockets,
another is handled entirely by vite, and the last one which was custom developed for this application.
The HTTP endpoints developed for this application are "/create", "/join", and "/findroom". The
"/create" endpoint creates a new room on GET and assigns it a websocket server. "/join" expects the
body of the POST request to have a roomcode attached to it, and checks if that roomcode exists. If it
does, it returns code 200 and a json object containing the information of the room. The "/findroom"
endpoint is what verifies a room exists before the "/join" endpoint is called - it expects a
roomcode in the body of the POST request, and returns a boolean and appropriate 200 or 404 status
code based on whether a room exists or not.

2.7
The REST API framework that will be used for this project is express. It's availability within the
npm library, it's minimal boilerplate code, and common usage in the industry show that it is one of
the best available.

2.8
not recording user data, TLS (/HTTPS), justify (risk analysis) of system misuse, predictable IDs

The application has a few built-in security measures, and adding onto those by using TLS over HTTP
would definitely increase the security, but the system does not handle sensitive user data - it
does not have a login/account system, and rooms are not password protected, so security on the
client side is not particularly a priority. The only real flaw in the security is how
predictable the current room IDs are (they count up starting from 1), however this is something
which can be fixed fairly quickly.

2.9
[images of the UI testing thing - in image evidence folder]

2.10
line segment system and how its communicated over the network, the infinite canvas thing

sequenceDiagram
    participant ViteServer
    participant WsServer
    participant Host
    participant Participants
    Host->>+ViteServer: Webpage request
    ViteServer->>-Host: Host Page

    Host->>+WsServer: Open room request
    WsServer-)Host: Room has been opened

    Participants->>+ViteServer: Webpage request
    ViteServer->>-Participants: Participation page

    Participants->>+WsServer: Join room

    Participants-)WsServer: New strokes
    WsServer-)Participants: Strokes drawn by others
    Host-)WsServer: New strokes
    WsServer-)Host: Strokes drawn by others

    WsServer->>-Participants: Leave room

    Host-)WsServer: Close room request
    WsServer->>-Host: Room has been closed

??? _____________

[ss: 2.10 - vite ws host participant sequence diagram]
[ss: 2.10 - main screen on mobile]
[ss: 2.10 - main screen on desktop]

2.11
The project aims to be lightweight and usable, even on older devices and devices with lower output
capabilities. The front end uses `useRef` from react to help with performance, and none of the
mobile devices that the application was tested on did not heat up during testing, indicating
lower battery usage compared to a more hardware intensive application.

2.12
github issues for test cases
test cases for typical scenarios

Manual UI tests:
. draw a line on the canvas
. create a room using the host link
. join a room using the participate link
. draw a line and see if it appears on another host
. shift the canvas around to check local and remote originating lines move correctly
Integration tests:
. test adding a record to the strokes collection in the database
Non-functional tests:
. test drawing loads of lines on a canvas and checking the system resource usage for abnormalities


2.13
document what has been discussed before, and how we're going to tackle these things

----------------- begin email -----------------
Hi [Supervisor],

The application is in a stable, usable state, but is missing major test coverage and styling. As
I said, it works and can be deployed, but requires more work. I also realise the room IDs are
predictable and easy to guess, but that should be a fairly quick fix.

I've attached the app development report below.


Thanks,
Dan :)

27.11.25
-----------------  end email  -----------------



part 3:

3.1
[ss: install node]
[ss: install vite]
[ss: install vitest]
[ss: install express and ws]
Subjectively, the IDE could be any text editor, and is therefore not a necessary development tool.

3.2
[ss: use of ide to manage files]

3.3
[ss: use of automation facilities (vite build)]

3.4


3.5


3.6
works, but janky

3.11
room code generator

3.12
change stroke history array into circular buffer

3.16
Searching and sorting the application is achieved through filtering line segments based on whether
they're visible on-screen or not. Due to the infinite canvas feature, line segments are frequently
not all on-screen, and therefore do not need to be drawn. However, this filtering does not require
efficient sorting or searching, as every line segment has to be drawn or checked anyway.

3.17
The data used in the application does not require sorting or searching, as it becomes sorted on definition.
As the data is created, it is sorted by "time of creation", which is the line segments as the stroke is
drawn. Searching is not necessary as data is grouped as it's created and individual data points are never
isolated. While drawing a single line segment is required fairly often, it's only drawn after the line segment
that was created directly before it and before the line segment that was created directly after it.

3.23
no login system, so not really applicable

3.24
save button to save current view as png

3.25


3.26


3.27
[ss: 3.27 - as close to IDE debugging as ill get]

3.28


3.29
[ss: 3.29 - optimisation 1 - remove method bc useless]
[ss: 3.29 - optimisation 2 - deleted these files to make maintenance easier]
[ss: 3.29 - optimisation 3 - recieved offscreen strokes are not drawn]

3.30
[ss: 3.30 - jsdoc comment]

3.31
[ss: 3.31 - multiple jsdoc comments]


part 4: testing and stuff

4.1
[ss: use of an appropriate emulator]

4.2
[image of multiple different phones connected to a single host]

4.3
HTTP integration tests, positive and negative responses

4.4



part 5:

5.1
[ss: deploy app to mobile]

5.2
https://capacitorjs.com/docs/web/progressive-web-apps
turns web page into an app

capacitor, build script, apk













